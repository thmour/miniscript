<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>miniscript</title>
    <link rel="stylesheet" href="css/style.css" media="screen" type="text/css" />
    <link type="text/css" rel="stylesheet" href="css/shCoreMini.css" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
    <div id="bar">
        <table>
            <tr>
                <td>
                    <span id="logo">
                        mini
                    </span>
                </td>
                <td>
                    <div id='cssmenu'>
                        <ul>
                            <li><a href='#'><span>Try</span></a></li>
                            <li><a href='#'><span>Documentation</span></a></li>
                            <li class='last'><a href='https://github.com/thmour/miniscript' target="_blank"><span>View on Github</span></a></li>
                        </ul>
                    </div>
                </td>
            </tr>
        </table>
    </div>
    <span id="bug"></span>
    <p>
        <span class='header'>What?</span><br><br>
        miniscript is a minimal dialect of javascript. It inherits every good part of Python, Ruby and C++. You can compile the code to javascript or run it directly from the console.
    </p>
    <p>
        <span class='header'>Why?</span><br><br>
        It is semicolon free, indent independent, DRY, readable and easy to learn. At the end, it's all javascript!
    </p>
    <p>
        <span class='header'>Install:</span><br><br>
        You can install the miniscript compiler using the following command:
    </p>
    <p class="command">$ npm install miniscript -g</p>
    <p>
        then you can either run your script, or output the javascript file:
    </p>
    <p class="command">
        $ mini [run] myscript[.mini]<br>
        $ mini  out  myscript[.mini] [output_name[.mini]]
    </p>
    <p class="middle">
        <span class='header'>Let's begin!</span><br><br>
        Below is your first hello world program:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            print 'Hello World', '!'
        </pre>
        <pre class="brush: mini;">
            console.log('Hello World', '!');
        </pre>
    </code>
    <p class="middle">
        As you see it resembles python, how about functions?
    </p>
    <code class="block">
        <pre class="brush: mini;">
            foo = # bar, baz {
                print bar, baz
            }
            &nbsp;
        </pre>
        <pre class="brush: js;">
            var foo;
            foo = function(bar, baz) {
                console.log(bar, baz);
            };
        </pre>
    </code>
    <p class="middle">
        foo is the name of the function, and it can be used inside it to achieve recursion.
        As you saw many things are considered obvious and have been removed from the miniscript syntax like parentheses and code blocks.
        Next stop, assignments:
    </p>
    <code class="block">
        <pre class="brush: mini;">                     
            x = 5
            
            foo = # {
                return 'maria', 21
            }

            name, age = foo()

            y = x = 5
            x = x + (y = 6)
        </pre>
        <pre class="brush: js;">
            var x, foo, name, age, y;
            x = 5;
            foo = function() {
                return ['maria', 21];
            };
            _c = foo();
            name = _c[0];
            age = _c[1];
            y = x = 5;
            x = x + (y = 6);
        </pre>
    </code>
    <p class="middle">
        This is what you can only do with assignments (for now).
        If you want to make an assignment when the compiler expects a value, wrap it inside parentheses.
        Let's continue with a full if statement:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            a = 5

            if a < 1
                print 'a is less than 1'
            elif a < 4
                print 'a is less than 4'
            else
                print 'a is greater than or equal to 4'
            ;
        </pre>
        <pre class="brush: js;">
            var a;
            a = 5;
            if (a < 1) {
                console.log('a is less than 1');
            } else if (a < 4) {
                console.log('a is less than 4');
            } else {
                console.log('a is greater than or equal to 4');
            }
        </pre>
    </code>
    <p class="middle">
        Only a ';' is required to finish an if statement, the same goes for other statements containing code blocks.
        Variables start with a lowercase letter while classes start with uppercase one. About time for a switch statement:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            switch john.likes
	            case 'basket', 'football'
		            send_message(john, 'What team you support?')
	            case 'squash'
		            send_message(john, 'I don\'t know much about it')
	            default
		            send_message(john, 'Whatever...')
            ;
            &nbsp;
            &nbsp;
            &nbsp;
        </pre>
        <pre class="brush: js;">
            switch (john.likes) {
                case 'basket':
                case 'football':
                    send_message(john, 'What team you support?');
                    break;
                case 'squash':
                    send_message(john, 'I don\'t know much about it');
                    break;
                default:
                    send_message(john, 'Whatever...');
            }
        </pre>
    </code>
    <p class="middle">
        Pretty neat, huh? At least miniscript tries to keep it simple and elegant.
        Now we can check out some for loops:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            obj = { a:1 b:2 c:3 }

            db =  { user:'peter' age:21 },
                  { user:'john'  age:32 },
                  { user:'ralph' age:27 }

            for i of 1..5
	            print i
            ;

            for key in obj
	            print key + ':', obj[key]
            ;

            String::capitalize = # {
                return this:0.toUpperCase() + this.slice(1)
            }

            for user, age in db
                print "%user.capitalize() is %{age + 1} years old"
            ;
            &nbsp;
            &nbsp;
        </pre>
        <pre class="brush: js;">
            var obj, db, i, key, user, age, _i, _l;
            obj = { a: 1, b: 2, c: 3 };
            db = [{user: 'peter', age: 21},
                  {user: 'john' , age: 32},
                  {user: 'ralph', age: 27}];

            for (i = 0; ++i <= 5;) {
                console.log(i);
            }

            for (key in obj) {
                console.log(key + ':', obj[key]);
            }

            String.prototype.capitalize = function() {
                return this[0].toUpperCase() + this.slice(1);
            };

            for (_i = -1, _l = db.length; ++_i < _l;) {
                user = db[_i].user;
                age = db[_i].age;
                console.log(user.capitalize() + " is " + (age + 1) + " years old");
            }
        </pre>
    </code>
    <p class="middle">
        You see that the for in behaves different when there are more than one iterators.
        This is more useful than splitting every member of an object into 2 variables. 
        You can also avoid the "[]" on the first level of the assignment.
        Now we proceed to classes. Here is the first example:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            class Animal { group, colors, legs }

            class Dog : Animal (@name, colors, @breed)
		        super 'mammal', colors, 4
            ;

            Dog::pet = # {
	            print 'wuf wuf!'
            }

            my_dog = new Dog('frisky', ['brown', 'white'], 'corgi')

            my_dog.pet()   
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp; 
        </pre>
        <pre class="brush: js;">
            var my_dog;
            function Animal(group, colors, legs) {
                this.group = group;
                this.colors = colors;
                this.legs = legs;
            }
            function Dog(name, colors, breed) {
                Animal.call(this, 'mammal', colors, 4);
                this.name = name;
                this.breed = breed;
            }
            Dog.prototype = Object.create(Animal.prototype);
            Dog.prototype.pet = function() {
                console.log('wuf wuf!');
            };
            my_dog = new Dog('frisky', ['brown', 'white'], 'corgi');
            my_dog.pet();
        </pre>
    </code>
    <p class="middle">
        Right after the class and its name, you can define either an object or a function.
        Optional body generates "this.member = member" code and "super" if needed. One more example:
    </p>
    <code class="block">
        <pre class="brush: mini;">
            class Point {x, y}

            class Point3 : Point {z}

            Point3.add = # p1, p2 {
	            return new Point3(p1.x + p2.x,
                                  p1.y + p2.y, 
					              p1.z + p2.z)
            }

            print Point3.add(new Point3(1,2,3), new Point3(1,1,1))
            //x:2, y:3, z:4
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
        </pre>
        <pre class="brush: js;">
            var _utils = {
                extend: function(child, parent) {
                    child.prototype = Object.create(parent.prototype);
                    child.prototype.constructor = child;
                }
            };
            function Point(x, y) {
                this.x = x;
                this.y = y;
            }
            function Point3(x, y, z) {
                Point.call(this, x, y);
                this.z = z;
            }
            _utils.extend(Point3, Point);
            Point3.add = function(p1, p2) {
                return new Point3(p1.x + p2.x, p1.y + p2.y, p1.z + p2.z);
            };
            console.log(Point3.add(new Point3(1, 2, 3), new Point3(1, 1, 1)));
        </pre>
    </code>
    <p class="middle">
        As you see there are 2 types of declaring classes, one with object notation and the other with function constructor.
        Utils is a library that provides some basic scripts to save some space of the output file avoiding unnecessary repetitions.
    </p>
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushMini.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</body>
</html>